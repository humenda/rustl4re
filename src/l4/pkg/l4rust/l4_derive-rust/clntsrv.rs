//! attributes to generate client and server implementations
use proc_macro::TokenStream;
use quote::quote;
use syn::{Attribute, Fields, Generics, Ident, Lit, Meta, NestedMeta,
        Result, Visibility};
use syn::spanned::Spanned;
use std::str::FromStr;

pub struct ServerOpts {
    pub trait_name: syn::Ident,
    pub cache: usize, // in bytes
}

pub fn gen_server_struct(name: proc_macro2::Ident, attrs: Vec<Attribute>,
                    vis: Visibility, generics: Generics, fields: Fields,
                    opts: &ServerOpts)
                    -> proc_macro::TokenStream {
    // duplicate names and types of fields, because quote! moves them
    let initialiser_names: Vec<_> = fields.iter().map(|f| f.ident.clone()).collect();
    let arg_names: Vec<_> = fields.iter().map(|f| f.ident.clone()).collect();
    let arg_types: Vec<_> = fields.iter().map(|f| f.ty.clone()).collect();
    let field_iter = fields.iter();
    let ServerOpts { trait_name, cache } = opts;
    // Implement caching, if requested, needs a struct member, code in the new
    // function and impl blocks
    let (cmember, cnew, cimpl) = match cache {
        0 => (quote! { }, quote! { }, quote! { }),
        n => {
            (quote! { __cache: [u8; #n], },
             quote! { __cache: [0u8; #n], },
             quote! {
                 impl l4::ipc::server::Cache for #name {
                     #[inline]
                     fn get_cache(&mut self) -> &mut [u8] {
                         &mut self.__cache
                     }
                     #[inline]
                     fn get_cache_size(&self) -> usize { #n }
                 }
                 impl l4::ipc::server::CacheFiller<str> for #name {
                     #[inline]
                     fn fill_with(&mut self, i: &str) -> l4::error::Result<&mut str> {
                         if i.len() > self.__cache.len() {
                             return Err(l4::error::Error::Generic(
                                 l4::error::GenericErr::MsgTooLong));
                         }
                         Ok(unsafe {
                             core::ptr::copy_nonoverlapping(
                                 i.as_ptr(), self.__cache.as_mut_ptr(), i.len());
                             core::str::from_utf8_unchecked_mut(&mut self.__cache[0..i.len()])
                         })
                     }
                 }
                 impl l4::ipc::server::CacheFiller<[u8]> for #name {
                     #[inline]
                     fn fill_with(&mut self, i: &[u8]) -> l4::error::Result<&mut [u8]> {
                         if i.len() > self.__cache.len() {
                             return Err(l4::error::Error::Generic(
                                 l4::error::GenericErr::MsgTooLong));
                         }
                         Ok(unsafe {
                             core::ptr::copy_nonoverlapping(
                                 i.as_ptr(), self.__cache.as_mut_ptr(), i.len());
                             &mut self.__cache[0..i.len()]
                         })
                     }
                 }
             })
        }
    };

    let gen = quote! {
        #[repr(C)]
        #(#attrs)*
        #vis struct #name #generics {
            __dispatch_ptr: ::l4::ipc::Callback,
            __cap: crate::l4::cap::CapIdx,
            #(#field_iter,)*
            #cmember
            __pin: core::marker::PhantomPinned
        }

        impl #name {
            /// Create a new #name instance
            ///
            /// The first argument is the IPC gate that this server is bound to.
            /// For example: `#name::new(my_cap, #(#arg_names),*)`.
            fn new(cap: l4::cap::CapIdx, #(#arg_names: #arg_types),*) -> #name {
                #name {
                    __dispatch_ptr: crate::l4::ipc::server_impl_callback::<#name>,
                    __cap: cap,
                    #(#initialiser_names,)*
                    #cnew
                    __pin: core::marker::PhantomPinned
                }
            }
        }
        unsafe impl crate::l4::ipc::types::Callable for #name { }
        impl crate::l4::ipc::types::Dispatch for #name {
            #[inline]
            fn dispatch(&mut self, tag: crate::l4::ipc::MsgTag,
                        mr: &mut l4::utcb::UtcbMr,
                        bufs: &mut l4::ipc::BufferAccess)
                    -> crate::l4::error::Result<crate::l4::ipc::MsgTag> {
                // op_dispatch is auto-generated by the iface! macro
                self.op_dispatch(tag, mr, bufs)
            }
        }
        impl l4::ipc::Demand for #name {
            const CAP_DEMAND: u8 = <Self as #trait_name>::CAP_DEMAND;
        }
        impl l4::cap::Interface for #name {
            #[inline]
            unsafe fn raw(&self) -> l4::cap::CapIdx {
                self.__cap
            }
        }
        impl l4::ipc::CapProviderAccess for #name {
            unsafe fn access_buffers(&mut self) -> l4::ipc::BufferAccess {
                panic!("Not implemented for servers");
            }
        }
        #cimpl
    };
    gen.into()
}

pub fn parse_client_meta(meta: syn::AttributeArgs) -> Result<(Ident, u32)> {
    let mut traitname = None;
    let mut demand = 0;
    for item in meta {
        let item = match item {
            NestedMeta::Meta(m) => m,
            NestedMeta::Literal(l) => err!(l, "Literals not allowed"),
        };
        match item {
            Meta::Word(tn) => traitname = Some(tn),
            Meta::NameValue(nv) => {
                if nv.ident != "demand" {
                    err!(nv.ident, "Only `demand = NUM` allowed");
                }
                demand = match nv.lit {
                    Lit::Int(i) => i.value() as u32,
                    _ => err!(nv.ident, "Demand can only be a positive integer number"),
                };
            },
            Meta::List(ml) => err!(ml, "Invalid nesting of attributes"),
        };
    }
    if traitname.is_none() {
        err!("No IPC interface trait specified");
    }
    Ok((traitname.unwrap(), demand))
}

pub fn gen_client_struct(name: proc_macro2::Ident, attrs: Vec<Attribute>,
                    vis: Visibility, generics: Generics, trait_name: Ident,
                    demand: u32)
                -> proc_macro::TokenStream {
    let slot_type: syn::Type = match demand {
        0 => syn::parse(TokenStream::from_str("l4::ipc::Bufferless").unwrap()).unwrap(),
        _ => syn::parse(TokenStream::from_str("l4::ipc::BufferManager").unwrap()).unwrap()
    };
    let gen = quote! {
        #(#attrs)*
        #vis struct #name #generics {
            __cap: crate::l4::cap::CapIdx,
            __slots: #slot_type,
            __pin: core::marker::PhantomPinned,
        }

        impl crate::l4::cap::Interface for #name {
            #[inline]
            unsafe fn raw(&self) -> crate::l4::cap::CapIdx {
                self.__cap
            }
        }
        impl crate::l4::cap::IfaceInit for #name {
            fn new(c: crate::l4::cap::CapIdx) -> Self {
                #name {
                    __cap: c,
                    __slots: <#slot_type as l4::ipc::CapProvider>::new(),
                    __pin: core::marker::PhantomPinned,
                }
            }
        }
        impl #trait_name for #name { }

        impl l4::ipc::CapProviderAccess for #name {
            unsafe fn access_buffers(&mut self) -> l4::ipc::BufferAccess {
                use l4::ipc::CapProvider;
                self.__slots.access_buffers()
            }
        }
    };
    gen.into()
}
